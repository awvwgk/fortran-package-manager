!> Definitions and templates to create mesonbuild enabled source distributions.
module fpm_dist_meson
  use fortran202x_split, only : split
  use fpm_dependency, only : dependency_tree_t
  use fpm_dist_source, only : source_dist_t, new_source_dist
  use fpm_error, only : error_t, fatal_error
  use fpm_filesystem, only : join_path
  use fpm_installer, only : installer_t
  use fpm_manifest, only : package_config_t, executable_config_t, get_package_data
  use fpm_strings, only : string_t, str_ends_with
  use fpm_versioning, only : char
  implicit none
  private

  public :: meson_dist_t, new_meson_dist
  public :: configure_output

  type :: meson_dist_t
  contains
    procedure :: create_dist
    procedure :: create_project
  end type meson_dist_t

  !> Default name of the meson build file
  character(len=*), parameter :: meson_build = "meson.build"

  !> Default name of the subprojects directoru
  character(len=*), parameter :: meson_subprojects = "subprojects"

  !> Just a newline character
  character(len=*), parameter :: nl = new_line('a')

  !> Project declaration for the meson build file.
  !> Input: NAME, VERSION
  character(len=*), parameter :: meson_project(*) = [character(len=128):: &
    "# This meson build file was automatically generated by fpm", &
    "project(", &
    "  '@NAME@',", &
    "  'fortran',", &
    "  version: '@VERSION@',", &
    "  meson_version: '>=0.53',", &
    ")", &
    "install = not (meson.is_subproject() and get_option('default_library') == 'static')"]

  !> Project configuration.
  character(len=*), parameter :: meson_config(*) = [character(len=128):: &
    "# Basic configuration for Fortran build", &
    "# makes sure we always can access the Fortran compiler and the host OS", & 
    "fc = meson.get_compiler('fortran')", &
    "os = host_machine.system()", &
    "", &
    "# Must be added on Windows platforms to avoid link errors", &
    "if os == 'windows'", &
    "  add_project_link_arguments(", &
    "    '-Wl,--allow-multiple-definition',", &
    "    language: 'fortran',", &
    "  )", &
    "endif"]

  !> Declaration of a library target of the project, due to fpm's constraints
  !> there will always be at most one library target in a project.
  !> Input: VARIABLE, DEPENDENCY
  character(len=*), parameter :: meson_library(*) = [character(len=128):: &
    "# Create main library target of the project", &
    "@VARIABLE@_lib = library(", &
    "  meson.project_name(),", &
    "  sources: @VARIABLE@_srcs,", &
    "  version: meson.project_version(),", &
    "  dependencies: @DEPENDENCY@,", &
    "  install: install,", &
    ")", &
    "", &
    "# Export library target as dependency for other projects", &
    "@VARIABLE@_inc = @VARIABLE@_lib.private_dir_include()", &
    "@VARIABLE@_dep = declare_dependency(", &
    "  link_with: @VARIABLE@_lib,", &
    "  dependencies: @DEPENDENCY@,", &
    "  include_directories: @VARIABLE@_inc,", &
    ")"]

  !> Declaration of an installable executable target.
  !> Input: VARIABLE, NAME, DEPENDENCY
  character(len=*), parameter :: meson_executable(*) = [character(len=128):: &
    "executable(", &
    "  '@NAME@',", &
    "  @VARIABLE@_exe_srcs,", &
    "  dependencies: @DEPENDENCY@,", &
    "  install: install,", &
    ")"]

  !> Declaration of an example executable target.
  !> Input: VARIABLE, NAME, DEPENDENCY
  character(len=*), parameter :: meson_example(*) = [character(len=128):: &
    "executable(", &
    "  '@NAME@',", &
    "  @VARIABLE@_exe_srcs,", &
    "  dependencies: @DEPENDENCY@,", &
    "  install: false,", &
    ")"]

  !> Declaration of an unit test.
  !> Input: VARIABLE, NAME, DEPENDENCY
  character(len=*), parameter :: meson_test(*) = [character(len=128):: &
    "test(", &
    "  '@NAME@',", &
    "  executable(", &
    "    '@NAME@',", &
    "    @VARIABLE@_test_srcs,", &
    "    dependencies: @DEPENDENCY@,", &
    "    install: install,", &
    "  )", &
    ")"]

  !> Declaration of another fpm-enabled project as dependency
  !> Input: VARIABLE, NAME, DEPENDENCY
  character(len=*), parameter :: meson_dependency(*) = [character(len=128):: &
    "@VARIABLE@_proj = subproject(", &
    "  '@NAME@',", &
    "  default_options: ['default_library=static'],", &
    ")", &
    "@VARIABLE@_dep = @VARIABLE@_proj.get_variable('@VARIABLE@_dep')", &
    "@DEPENDENCY@ += @VARIABLE@_dep"]

  !> Declaration of an external library dependency, try meson's dependency search
  !> first, than use the Fortran compiler to get the linked libraries
  !> Input: VARIABLE, NAME, DEPENDENCY
  character(len=*), parameter :: meson_link(*) = [character(len=128):: &
    "@VARIABLE@_dep = dependency('@NAME@', required: false)", &
    "if not @VARIABLE@_dep.found()", &
    "  @VARIABLE@_dep = fc.find_library('@NAME@', required: true)", &
    "endif", &
    "@DEPENDENCY@ += @VARIABLE@_dep"]

contains


subroutine new_meson_dist(self)
  type(meson_dist_t), intent(out) :: self
end subroutine new_meson_dist


subroutine create_dist(self, package, deps, installer, error)
  class(meson_dist_t), intent(inout) :: self
  type(package_config_t), intent(in) :: package
  type(dependency_tree_t), intent(in) :: deps
  class(installer_t), intent(inout) :: installer
  type(error_t), allocatable, intent(out) :: error

  integer :: i, unit
  character(len=:), allocatable :: subdir, destdir, manifest, output
  type(package_config_t) :: dependency
  type(source_dist_t) :: dist

  do i = 1, deps%ndep
    if (deps%dep(i)%name == package%name) cycle
    manifest = join_path(deps%dep(i)%proj_dir, "fpm.toml")
    call get_package_data(dependency, manifest, error, apply_defaults=.true.)
    if (allocated(error)) exit
    if (.not.allocated(dependency%library)) then
      call fatal_error(error, "Dependencies must provide a library")
      exit
    end if
    if (allocated(error)) exit
    call new_source_dist(dist)
    subdir = join_path(deps%dep(i)%proj_dir, dependency%library%source_dir)
    destdir = join_path(meson_subprojects, deps%dep(i)%name)
    call dist%add_dir(subdir, filter_source)
    call installer%install_list(dist%sources(:dist%nsrc), &
      destdir, deps%dep(i)%proj_dir, error)

    call prune_path(dist, deps%dep(i)%proj_dir)

    call self%create_project(output, dependency, dist, .true.)

    call installer%make_dir(join_path(installer%prefix, destdir), error)

    open(file=join_path(installer%prefix, destdir, meson_build), newunit=unit)
    write(unit, '(a)') output
    close(unit)
  end do
  if (allocated(error)) return

  call new_source_dist(dist)
  subdir = join_path(".", package%library%source_dir)
  call dist%add_dir(subdir, filter_source)
  call installer%install_list(dist%sources(:dist%nsrc), &
    ".", ".", error)

  call self%create_project(output, package, dist, .true.)

  open(file=join_path(installer%prefix, meson_build), newunit=unit)
  write(unit, '(a)') output
  close(unit)

end subroutine create_dist

pure function filter_source(string) result(filter)
  character(len=*), intent(in) :: string
  logical :: filter
  filter = str_ends_with(string, ".f90") .or. str_ends_with(string, ".F90") &
    &.or. str_ends_with(string, ".f") .or. str_ends_with(string, ".F")
end function filter_source

subroutine create_project(self, output, package, dist, is_dependency)
  class(meson_dist_t), intent(inout) :: self
  character(len=:), allocatable, intent(out) :: output
  type(package_config_t), intent(in) :: package
  type(source_dist_t), intent(in) :: dist
  logical, intent(in) :: is_dependency
  character(len=:), allocatable :: variable
  integer :: i

  variable = underscorify(package%name)

  output = get_meson_project(package)

  output = output // nl // get_meson_config()

  output = output // nl //&
    "# Collect all library dependencies" // nl // &
    "lib_deps = []" // nl

  if (allocated(package%dependency)) then
    do i = 1, size(package%dependency)
      output = output // nl // get_meson_dependency(package%dependency(i)%name, "lib_deps")
    end do
  end if

  if (allocated(package%build%link)) then
    do i = 1, size(package%build%link)
      output = output // nl // get_meson_link(package%build%link(i)%s, "lib_deps")
    end do
  end if

  if (allocated(package%library)) then
    output = output // nl // get_meson_sources(dist%sources(:dist%nsrc), variable)
    output = output // nl // get_meson_library(package)
  end if

  if (is_dependency) return

  if (allocated(package%executable).or.allocated(package%example)) then
    if (allocated(package%library)) then
      output = output // nl //&
        "# Collect all executable dependencies" // nl // &
        "exe_deps = ["//variable//"_dep]" // nl
    else
      output = output // nl //&
        "# Collect all executable dependencies" // nl // &
        "exe_deps = []" // nl
    end if
  end if

  if (allocated(package%executable)) then
    do i = 1, size(package%executable)
      output = output // nl // add_meson_app(package%executable(i), "exe_deps", &
        get_meson_executable)
    end do
  end if

  if (allocated(package%example)) then
    do i = 1, size(package%example)
      output = output // nl // add_meson_app(package%example(i), "exe_deps", &
        get_meson_example)
    end do
  end if

  if (allocated(package%test)) then
    if (allocated(package%library)) then
      output = output // nl //&
        "# Collect all development dependencies" // nl // &
        "dev_deps = ["//variable//"_dep]" // nl
    else
      output = output // nl //&
        "# Collect all development dependencies" // nl // &
        "dev_deps = []" // nl
    end if
  end if

  if (allocated(package%dev_dependency)) then
    do i = 1, size(package%dependency)
      output = output // nl // get_meson_dependency(package%dependency(i)%name, "dev_deps")
    end do
  end if

  if (allocated(package%test)) then
    do i = 1, size(package%test)
      output = output // nl // add_meson_app(package%test(i), "dev_deps", &
        get_meson_test)
    end do
  end if

end subroutine create_project

function get_meson_project(package) result(output)
  type(package_config_t), intent(in) :: package
  character(len=:), allocatable :: output

  call configure_output(meson_project, output, &
    name=package%name, version=char(package%version))

end function get_meson_project

function get_meson_config() result(output)
  character(len=:), allocatable :: output

  call configure_output(meson_config, output)

end function get_meson_config

function get_meson_library(package) result(output)
  type(package_config_t), intent(in) :: package
  character(len=:), allocatable :: output
  character(len=:), allocatable :: variable

  variable = underscorify(package%name)

  call configure_output(meson_library, output, &
    variable=variable, dependency="lib_deps")

end function get_meson_library

function add_meson_app(executable, dependency, get_meson_exe) result(output)
  class(executable_config_t), intent(in) :: executable
  procedure(get_meson_executable) :: get_meson_exe
  character(len=*), intent(in) :: dependency
  character(len=:), allocatable :: output
  character(len=:), allocatable :: this_dependency
  integer :: i

  if (allocated(executable%dependency).or.allocated(executable%link)) then
    this_dependency = underscorify(executable%name) // "_exe_dep"
    output = this_dependency // " = " // dependency
    if (allocated(executable%dependency)) then
      do i = 1, size(executable%dependency)
        output = output // nl // &
          get_meson_dependency(executable%dependency(i)%name, this_dependency)
      end do
    end if
    if (allocated(executable%link)) then
      do i = 1, size(executable%link)
        output = output // nl // get_meson_link(executable%link(i)%s, &
          this_dependency)
      end do
    end if
    output = output // nl // get_meson_exe(name=executable%name, &
      dependency=this_dependency)
  else
    output = get_meson_exe(name=executable%name, dependency=dependency)
  end if

end function add_meson_app

function get_meson_executable(name, dependency) result(output)
  character(len=*), intent(in) :: name
  character(len=*), intent(in) :: dependency
  character(len=:), allocatable :: output
  character(len=:), allocatable :: variable

  variable = underscorify(name)

  call configure_output(meson_executable, output, &
    name=name, variable=variable, dependency=dependency)

end function get_meson_executable

function get_meson_example(name, dependency) result(output)
  character(len=*), intent(in) :: name
  character(len=*), intent(in) :: dependency
  character(len=:), allocatable :: output
  character(len=:), allocatable :: variable

  variable = underscorify(name)

  call configure_output(meson_example, output, &
    name=name, variable=variable, dependency=dependency)

end function get_meson_example

function get_meson_test(name, dependency) result(output)
  character(len=*), intent(in) :: name
  character(len=*), intent(in) :: dependency
  character(len=:), allocatable :: output
  character(len=:), allocatable :: variable

  variable = underscorify(name)

  call configure_output(meson_test, output, &
    name=name, variable=variable, dependency=dependency)

end function get_meson_test

function get_meson_dependency(name, dependency) result(output)
  character(len=*), intent(in) :: name
  character(len=*), intent(in) :: dependency
  character(len=:), allocatable :: output
  character(len=:), allocatable :: variable

  variable = underscorify(name)

  call configure_output(meson_dependency, output, &
    name=name, variable=variable, dependency=dependency)

end function get_meson_dependency

function get_meson_link(name, dependency) result(output)
  character(len=*), intent(in) :: name
  character(len=*), intent(in) :: dependency
  character(len=:), allocatable :: output
  character(len=:), allocatable :: variable

  variable = underscorify(name)

  call configure_output(meson_link, output, &
    name=name, variable=variable, dependency=dependency)

end function get_meson_link

function get_meson_sources(sources, variable) result(output)
  type(string_t), intent(in) :: sources(:)
  character(len=*), intent(in) :: variable
  character(len=:), allocatable :: output
  integer :: i

  output = variable//"_srcs = files(" // nl
  do i = 1, size(sources)
    output = output//"  '"//sources(i)%s//"',"//nl
  end do
  output = output//")"//nl

end function get_meson_sources

subroutine configure_output(input, output, name, version, variable, dependency)
  character(len=*), intent(in) :: input(:)
  character(len=:), allocatable, intent(out) :: output
  character(len=*), intent(in), optional :: name
  character(len=*), intent(in), optional :: version
  character(len=*), intent(in), optional :: variable
  character(len=*), intent(in), optional :: dependency
  character(len=:), allocatable :: line
  integer, allocatable :: first(:), last(:)
  integer :: i, j, jfirst, jlast

  output = ""
  do i = 1, size(input)
    line = input(i)
    call split(line, "@", first, last)
    do j = size(first)-1, 2, -2
      jfirst = max(0, last(j-1))
      jlast = min(first(j+1), len_trim(line))
      select case(line(first(j):last(j)))
      case("NAME")
        if (present(name)) then
          line = line(1:jfirst) // name // line(jlast:)
        end if
      case("VERSION")
        if (present(version)) then
          line = line(1:jfirst) // version // line(jlast:)
        end if
      case("VARIABLE")
        if (present(variable)) then
          line = line(1:jfirst) // variable // line(jlast:)
        end if
      case("DEPENDENCY")
        if (present(dependency)) then
          line = line(1:jfirst) // dependency // line(jlast:)
        end if
      end select
    end do
    output = output // trim(line) // nl
  end do

end subroutine configure_output

pure function underscorify(input) result(output)
  character(len=*), intent(in) :: input
  character(len=len(input)) :: output
  character(len=*), parameter :: chars = &
    & "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789"
  integer :: i
  do i = 1, len(input)
    if (scan(input(i:i), chars) == 0) then
      output(i:i) = "_"
    else
      output(i:i) = input(i:i)
    end if
  end do
end function underscorify

subroutine prune_path(self, path)
  type(source_dist_t), intent(inout) :: self
  character(len=*), intent(in) :: path
  integer :: i, j

  do i = 1, self%nsrc
    j = index(self%sources(i)%s, path)
    if (j > 0) then
      self%sources(i)%s = self%sources(i)%s(j+len(path)+1:)
    end if
  end do
end subroutine prune_path

end module fpm_dist_meson
